workflow: session-insights-dev
description: Development workflow for session-insights CLI tool with failure diagnosis

agents:
  - role: engineer
  - role: reviewer

states:
  start:
    type: initial
    auto_transition: engineering

  engineering:
    instructions: |
      Implement the assigned task for the session-insights CLI tool.
      
      Follow Python best practices:
      - Use Pydantic v2 for models
      - Click for CLI commands
      - pytest for testing
      - Type hints throughout
      
      CRITICAL - CLI Task Decomposition:
      CLI implementation is a known high-risk area. If your task involves CLI work:
      1. NEVER implement argument parsing, dispatch, and business logic in a single task
      2. Break CLI tasks into these discrete layers:
         - Layer 1: Argument/option parsing with Click decorators
         - Layer 2: Command dispatch and routing
         - Layer 3: Business logic (call existing parser/analysis functions)
      3. Implement and test ONE layer at a time before proceeding
      4. If a CLI task is too large, signal "blocked" with a decomposition proposal
      
      CRITICAL - Failed Task Recovery:
      If this task failed in a previous cycle:
      1. Run diagnostics FIRST: check for missing dependencies, import errors, syntax issues
      2. Review the failure logs before writing any code
      3. Identify the specific blocker - do NOT simply retry the same approach
      4. If the same approach failed twice, you MUST try a different strategy
      
      Run tests before signaling done:
      `uv run pytest tests/ -x -q`
      
      Signal "done" when implementation is complete and tests pass.
      Signal "blocked" if you identify a systemic issue requiring task decomposition.
    on_signal:
      done:
        from: engineer
        next: reviewing
      blocked:
        from: engineer
        next: blocked
    timeout:
      duration: 30m
      action: nudge

  reviewing:
    instructions: |
      Review the implementation for correctness and quality.
      
      Verification steps:
      1. Read all changed files
      2. Run full test suite with coverage
      3. Test CLI manually if applicable
      4. Check for edge cases and error handling
      
      CLI-specific review:
      - Verify CLI layers are properly separated (parsing, dispatch, logic)
      - Ensure no monolithic command implementations
      - Check that Click decorators are minimal and focused
      
      Signal "approved" if quality is acceptable.
      Signal "needs_revision" with specific feedback if changes needed.
    on_signal:
      approved:
        from: reviewer
        next: finalize
      needs_revision:
        from: reviewer
        next: engineering
    timeout:
      duration: 15m
      action: nudge

  blocked:
    type: terminal
    on_entry:
      - action: log
        message: Task requires decomposition or manual intervention - escalating

  finalize:
    type: terminal
    on_entry:
      - action: commit
