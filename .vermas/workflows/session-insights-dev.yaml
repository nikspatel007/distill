workflow: session-insights-dev
description: Development workflow for session-insights CLI tool with failure diagnosis

agents:
  - role: engineer
  - role: reviewer

states:
  start:
    type: initial
    auto_transition: engineering

  engineering:
    instructions: |
      Implement the assigned task for the session-insights CLI tool.

      TASK ALIGNMENT CHECK (do this FIRST, before writing any code):
      Identify which KPI(s) this task will move. If you cannot name at least one
      of the KPIs below that this task directly advances, STOP and signal blocked
      with an explanation. Do not execute tasks that only improve infrastructure
      without moving a metric.

      KPIs (current status):
      - note_content_richness: 0% — CRITICAL, primary bottleneck
      - vermas_task_visibility: partial
      - cli_runs_clean: partial
      - obsidian_compatibility: on track

      MANDATORY PRIORITY: note_content_richness
      This KPI has had ZERO movement across all cycles. If any pending task
      targets note_content_richness (especially the analyze subcommand), you
      MUST pick it up before working on any other task. The analyze subcommand
      is the single highest-leverage item: it directly impacts both
      note_content_richness and vermas_task_visibility simultaneously.

      EXECUTION STALL PRE-CHECK (do this BEFORE starting work):
      List all pending tasks. If there are pending tasks and none are in_progress,
      immediately pick up the highest-priority pending task. Do not wait for
      external triggers. Execution stalls are a scheduling problem — if work
      exists and you are idle, start working.

      PRIORITY ORDER:
      1. note_content_richness (0% — this is the #1 priority)
         The analyze subcommand must produce rich, structured content from
         session data. Implement content extraction, summarization, and
         formatting logic — not just stubs.
      2. vermas_task_visibility (partial)
      3. cli_runs_clean (partial)
      4. obsidian_compatibility (on track — maintain, don't regress)

      CLI DECOMPOSITION PATTERN (required for all CLI work):
      This pattern has produced zero failures across multiple cycles. For any
      CLI-related task, decompose into three layers:
      1. Argument parsing — Click decorators, parameter validation
      2. Dispatch — routing from CLI entry point to business logic
      3. Logic — pure functions that transform data, independently testable
      Implement and test each layer separately. Do NOT build monolithic CLI
      handlers.

      Follow Python best practices:
      - Use Pydantic v2 for models
      - Click for CLI commands
      - pytest for testing
      - Type hints throughout

      Run tests before signaling done:
      `uv run pytest tests/ -x -q`

      If tests fail, fix them before signaling.

      Signal "done" when implementation is complete and tests pass.
      Signal "blocked" if you encounter infrastructure issues.

    on_signal:
      done:
        from: engineer
        next: reviewing
      blocked:
        from: engineer
        next: blocked
    timeout:
      duration: 30m
      action: nudge

  reviewing:
    instructions: |
      Review the engineer's implementation for the session-insights CLI tool.

      REVIEW CHECKLIST:
      1. Does the implementation move at least one KPI? Check specifically:
         - Does it advance note_content_richness? (highest priority)
         - Are there actual content extraction/formatting implementations,
           not just stubs or pass-through functions?
      2. CLI decomposition: Is the code separated into parsing, dispatch,
         and logic layers? Reject monolithic CLI handlers.
      3. Test coverage: Are there tests for the logic layer independent of
         CLI invocation?
      4. Does `uv run pytest tests/ -x -q` pass?

      Focus on functional correctness and KPI impact.
      Signal "approved" if the code is correct, tested, and advances a KPI.
      Signal "needs_revision" with specific feedback if changes are needed.
      Signal "blocked" if you cannot review due to infrastructure issues.

    on_signal:
      approved:
        from: reviewer
        next: finalize
      needs_revision:
        from: reviewer
        next: engineering
      blocked:
        from: reviewer
        next: blocked
    timeout:
      duration: 15m
      action: nudge

  finalize:
    on_entry:
      - action: commit
    type: terminal

  blocked:
    on_entry:
      - action: log
        message: "Workflow blocked - environment validation failed or infrastructure issue"
    type: terminal
